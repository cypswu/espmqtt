<!--
===============================================================================
  檔案名稱：index.html
  專案名稱：品茶 QR Code 管理系統
  版本號碼：v1.6.5 ─ 2025-05-08 
===============================================================================

【功能摘要】
  · SPA 單頁：輸入／掃描／載入 JSON → 產生與還原 QR
  · 支援 PNG 下載、File System Access API 儲存、雲端 JSON 模式
  · 三分頁：產生｜掃描｜使用說明；即時驗證/Tooltip 提升 UX

【Authors & Tools】
  ▸ Author       : cypswu
  ▸ Scaffolding  : Gemini 2.5 Pro
  ▸ Refinement   : ChatGPT-o3

【主要相依】
  ▸ Bootstrap 5.3.2　　　 (CSS / JS bundle)
  ▸ Bootstrap Icons 1.11
  ▸ QRious 4.0.2　　　　  (Canvas QR 產生)
  ▸ html5-qrcode 2.3.8　  (相機掃描)
  ▸ LZ-String 1.4.4　　  (JSON 壓縮 / 解壓)

【瀏覽器支援】
  · Chrome / Edge 96+（完整支援 File System Access API）
  · Firefox 95+　　　（自動降級為 <a download> 下載）
  · iOS / Android 主流瀏覽器皆可掃描與載入

【License】MIT

【修訂紀錄】
  ▸ v1.6.5 ─ 2025-05-08 
      - 下載 PNG 內嵌茶名；畫面即時顯示茶名
      - 檔名保留中文，只過濾系統保留字
      - handleSaveQr() 與 fallback 下載改用 buildQrWithCaptionCanvas()
  ▸ v1.6.4 ─ 2025-05-04
      - 「掃描 QR Code」頁籤增加一個「由此載入 JSON 檔案顯示」的按鈕
  ▸ v1.6.2 ─ 2025-05-02
      - 重構註解：將多餘 console.log 註解，保留 warn/error
      - 程式掃過：確認壓縮/解壓、QR 流程與 v1.6.1 一致
  ▸ v1.6.1 ─ 2025-05-01
      - 「使用說明」頁籤：新增安全性、FAQ
      - 下載機制：File System + <a download> 雙模式
      - JSON：parseQrData() 支援 {v,d} 自動解壓，CORS 失敗給手動下載
  ▸ v1.6.0 ─ 2025-05-01
      - 首版導入 File System Access & 雲端 JSON 模式
===============================================================================
-->
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>品茶 QR Code 管理系統</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #5a7d2c;
            --secondary-color: #d4c3a0;
            --background-gradient: linear-gradient(to bottom right, #f8f5f0, #e9e0d1); /* Slightly adjusted gradient */
            --text-color: #333;
            --card-border-color: #e0d8c7;
            --accordion-button-bg: #f8f9fa;
            --accordion-button-active-bg: #e7f0e1;
        }

        body {
            font-family: 'Noto Serif TC', serif;
            background: var(--background-gradient);
            color: var(--text-color);
            padding-bottom: 70px; /* Increased padding */
        }

        h1, h2, h3, h4, h5, h6, .navbar-brand, .nav-link.active, .accordion-button:not(.collapsed) {
            font-family: 'Playfair Display', serif;
            color: var(--primary-color);
        }
        h1 {
            font-weight: 700;
        }

        .nav-tabs {
             border-bottom: 1px solid var(--card-border-color);
        }

        .nav-tabs .nav-link {
            color: var(--primary-color);
            border: 1px solid transparent; /* Add transparent border for consistent height */
             margin-bottom: -1px; /* Overlap border */
             border-top-left-radius: 0.375rem;
             border-top-right-radius: 0.375rem;
             padding: 0.75rem 1.25rem; /* Slightly larger padding */
        }

        .nav-tabs .nav-link.active {
            background-color: #fff; /* Make active tab background white */
            border-color: var(--card-border-color) var(--card-border-color) #fff; /* Match card border */
            font-weight: bold;
            color: var(--primary-color);
        }
         .nav-tabs .nav-link:hover:not(.active) {
             border-color: transparent transparent var(--card-border-color) transparent;
             background-color: #f8f5f0; /* Slight hover effect */
         }

        .tab-content {
            padding-top: 1.5rem; /* Add space below tabs */
        }

        .accordion-item {
            border: 1px solid var(--card-border-color);
            margin-bottom: 0.5rem; /* Add space between items */
            border-radius: 0.375rem; /* Rounded corners for items */
            overflow: hidden; /* Ensure children conform to rounded corners */
        }
        .accordion-item:first-of-type {
             border-top-left-radius: 0.375rem;
             border-top-right-radius: 0.375rem;
        }
         .accordion-item:last-of-type {
             border-bottom-left-radius: 0.375rem;
             border-bottom-right-radius: 0.375rem;
             margin-bottom: 0;
         }

        .accordion-button {
            background-color: var(--accordion-button-bg);
            color: var(--text-color);
            font-weight: bold; /* Make section titles bolder */
            border-bottom: 1px solid var(--card-border-color); /* Separator line */
        }
         .accordion-item:last-of-type .accordion-button.collapsed {
             border-bottom: 0; /* Remove border if last item and collapsed */
         }

        .accordion-button:not(.collapsed) {
            background-color: var(--accordion-button-active-bg);
            color: var(--primary-color); /* Use primary color when active */
            box-shadow: inset 0 -1px 0 var(--card-border-color); /* Keep bottom border */
        }

        .accordion-button:focus {
            box-shadow: 0 0 0 0.2rem rgba(90, 125, 44, 0.25); /* Primary color focus */
            z-index: 3; /* Ensure focus outline is visible */
        }
        .accordion-body {
            background-color: #fff; /* White background for content */
        }

        .btn {
             border-radius: 0.375rem;
             padding: 0.5rem 1rem; /* Consistent padding */
             font-weight: 500; /* Slightly bolder text */
             transition: all 0.2s ease-in-out; /* Smoother transitions */
        }

        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: #fff;
        }

        .btn-primary:hover {
            background-color: #486423;
            border-color: #486423;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            border-color: var(--secondary-color);
            color: #333;
        }

        .btn-secondary:hover {
            background-color: #c3b28f;
            border-color: #c3b28f;
            transform: translateY(-1px);
             box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
         .btn-success { /* Style save button */
             background-color: #28a745;
             border-color: #28a745;
         }
         .btn-success:hover {
             background-color: #218838;
             border-color: #1e7e34;
             transform: translateY(-1px);
             box-shadow: 0 4px 8px rgba(0,0,0,0.1);
         }
         .btn-outline-secondary {
             color: var(--primary-color);
             border-color: var(--primary-color);
         }
         .btn-outline-secondary:hover {
             background-color: var(--accordion-button-active-bg);
             color: var(--primary-color);
         }


        .card {
            border: 1px solid var(--card-border-color);
            border-radius: 0.5rem;
            box-shadow: 0 6px 12px rgba(0,0,0,0.08); /* Slightly softer shadow */
            background-color: #fff; /* Ensure card background is white */
        }
        .card-body {
            padding: 1.5rem; /* More padding in cards */
        }

        .form-control, .form-select {
            border-radius: 0.375rem;
            border: 1px solid #ced4da;
        }
        .form-control:focus, .form-select:focus {
             border-color: #a8c589; /* Primary color related focus */
             box-shadow: 0 0 0 0.2rem rgba(90, 125, 44, 0.25);
        }
        .form-label {
            margin-bottom: 0.5rem;
            font-weight: 500; /* Slightly bolder labels */
        }

        #qrCodeResult img,
        #qrCodeResult canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid var(--card-border-color);
            border-radius: 0.375rem;
            margin-top: 1rem;
            background-color: white; /* Ensure QR code background is white */
            padding: 10px; /* Add padding around QR code */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        #reader {
            width: 100%; /* Make reader take full width of container */
            max-width: 400px; /* Limit max width */
            margin: 1rem auto; /* Center and add margin */
            border: 2px dashed var(--secondary-color); /* Dashed border */
            border-radius: 0.5rem;
            overflow: hidden; /* Ensure rounded corners */
            background-color: #f8f9fa; /* Light background for reader area */
            min-height: 200px; /* Ensure reader area has some height initially */
            display: flex; /* Use flexbox for centering placeholder */
            align-items: center;
            justify-content: center;
        }
        #reader video { /* Style the video element if possible */
             display: block;
             width: 100%;
             height: auto;
        }


        .list-group-item {
            word-break: break-word; /* Avoid long string overflow */
            padding: 0.75rem 1.25rem;
            border-color: var(--card-border-color); /* Match card border */
            background-color: #fff; /* Ensure white background */
        }
        .list-group-item:first-child {
             border-top-left-radius: 0; /* Remove radius if inside card */
             border-top-right-radius: 0;
        }
        .list-group-item:last-child {
             border-bottom-left-radius: 0;
             border-bottom-right-radius: 0;
        }

        .list-group-item strong {
             color: var(--primary-color);
             margin-right: 0.5em; /* Space after label */
        }

        .list-group-item img {
            max-width: 100%;
            height: auto;
            max-height: 250px; /* Increased max height */
            margin-top: 8px;
            border-radius: 0.375rem;
            border: 1px solid var(--card-border-color);
            display: block; /* Ensure image is block level */
        }
        .list-group-item pre { /* Style for textarea display */
            white-space: pre-wrap;
            word-wrap: break-word; /* Ensure long words wrap */
            margin: 0;
            font-family: inherit;
            font-size: inherit;
            background-color: #f8f9fa; /* Slight background for pre */
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 5px;
        }

        /* Hide default file input */
        input[type="file"] {
            display: none;
        }
        /* Custom file upload button style */
        .custom-file-upload {
            border: 1px solid var(--primary-color);
            display: inline-block;
            padding: 0.375rem 0.75rem; /* Match form control padding */
            cursor: pointer;
            background-color: #fff;
            color: var(--primary-color);
            border-radius: 0.375rem;
            transition: background-color 0.2s ease;
            margin-right: 5px; /* Space next to filename */
        }
        .custom-file-upload:hover {
            background-color: var(--accordion-button-active-bg);
        }
        .file-name-display {
            font-style: italic;
            color: #6c757d;
            font-size: 0.9em;
            word-break: break-all; /* Break long filenames */
        }
        #productImageFilePreview img {
             max-width: 100%; /* Allow image to scale */
             max-height: 200px;
             margin-top: 10px;
             border-radius: 0.375rem;
             border: 1px solid var(--card-border-color);
        }
        .alert {
            border-radius: 0.375rem;
            padding: 1rem 1.25rem;
        }
        /* Removed debug-info class as console logs are commented */
    </style>
</head>
<body>
    <div class="container mt-4 mb-5">
        <header class="text-center mb-5">
            <h1 class="display-5">品茶 QR Code 管理系統</h1>
        </header>

        <ul class="nav nav-tabs mb-4" id="teaTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="generate-tab" data-bs-toggle="tab" data-bs-target="#generateTabPane" type="button" role="tab" aria-controls="generateTabPane" aria-selected="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-qr-code-scan me-1" viewBox="0 0 16 16"><path d="M0 .5A.5.5 0 0 1 .5 0h3a.5.5 0 0 1 0 1H1v2.5a.5.5 0 0 1-1 0zm12 0a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-1 0V1h-2.5a.5.5 0 0 1-.5-.5zM.5 12a.5.5 0 0 1 .5.5V15h2.5a.5.5 0 0 1 0 1h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1 0-1H15v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7 2H2v5h5V2ZM3 3h3v3H3V3Zm2 8H4v1h1v-1Z"/><path d="M7 9H2v5h5V9Zm-4 1h3v3H3v-3Zm8-6h1v1h-1V4Z"/><path d="M9 2h5v5H9V2Zm1 1v3h3V3h-3ZM8 8v2h1v1H8v1h2v-2h1v2h1v-1h2v-1h-3V8H8Zm2 2H9V9h1v1Zm4 2h-1v1h-2v1h3v-2Zm-4 2v-1H8v1h2Z"/><path d="M12 9h2V8h-2v1Z"/></svg>
                    產生 QR Code
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="scan-tab" data-bs-toggle="tab" data-bs-target="#scanTabPane" type="button" role="tab" aria-controls="scanTabPane" aria-selected="false">
                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-camera-fill me-1" viewBox="0 0 16 16"> <path d="M10.5 8.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0"/> <path d="M2 4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-1.172a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 9.172 2H6.828a2 2 0 0 0-1.414.586l-.828.828A2 2 0 0 1 3.172 4zm.5 2a.5.5 0 1 1 0-1 .5.5 0 0 1 0 1m9-1a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0"/> </svg>
                    掃描 QR Code
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="help-tab" data-bs-toggle="tab" data-bs-target="#helpTabPane" type="button" role="tab" aria-controls="helpTabPane" aria-selected="false">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-info-circle me-1" viewBox="0 0 16 16"> <path d="M8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1m0 1a6 6 0 1 1 0 12A6 6 0 0 1 8 2m.93 4.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.194.897c-.194.897.105 1.319.808 1.319.545 0 .934-.252 1.019-.598l.088-.416c.063-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287.082-.38-.45-.083c-.294-.07-.352-.176-.288-.469l.194-.897c.194-.897-.105-1.319-.808-1.319-.545 0-.934.252-1.019.598l-.088.416c-.063-.293-.006.399.287.47l.451.081-.082.381z"/> <circle cx="8" cy="4.5" r="1"/> </svg>
                    使用說明
                </button>
            </li>
        </ul>

        <div class="tab-content" id="teaTabsContent">
            <div class="tab-pane fade show active" id="generateTabPane" role="tabpanel" aria-labelledby="generate-tab" tabindex="0">
                <div class="card mb-4">
                    <div class="card-body">
                        <form id="teaForm">
                            <div class="accordion" id="teaFormAccordion">
                                </div>

                            <div class="d-flex justify-content-between align-items-center mt-4 flex-wrap gap-3">
                                <button type="submit" class="btn btn-primary btn-lg">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-circle-fill me-1" viewBox="0 0 16 16"> <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M8.5 4.5a.5.5 0 0 0-1 0v3h-3a.5.5 0 0 0 0 1h3v3a.5.5 0 0 0 1 0v-3h3a.5.5 0 0 0 0-1h-3z"/> </svg>
                                    產生 QR Code
                                </button>
                                <div>
                                    <label for="loadQrInput" class="btn btn-secondary custom-file-upload">
                                         <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-upload me-1" viewBox="0 0 16 16"> <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/> <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708z"/> </svg>
                                        載入 QR Code
                                    </label>
                                    <input type="file" id="loadQrInput" accept="image/png, image/jpeg, image/gif">

                                    <label for="loadJsonInput" class="btn btn-secondary custom-file-upload ms-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-earmark-arrow-up me-1" viewBox="0 0 16 16"> <path d="M8.5 11.5a.5.5 0 0 1-1 0V7.707L6.354 8.854a.5.5 0 1 1-.708-.708l2-2a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 7.707z"/> <path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2M9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5z"/> </svg>
                                        載入 JSON
                                    </label>
                                    <input type="file" id="loadJsonInput" accept=".json" style="display:none;" >
                                </div>
                            </div>
                        </form>
                    </div>
                </div>

                <div id="qrCodeResult" class="mt-4 text-center" style="display: none;">
                     <div class="card">
                         <div class="card-body">
                             <h3 class="h5 mb-3">產生的 QR Code:</h3>
                             <canvas id="qrCanvas" width="420" height="420"></canvas>
                             <p id="qrTeaName" class="fw-bold mt-2"></p>
                             <div id="qrCodeImageContainer"></div> <button id="saveQrButton" class="btn btn-success mt-3">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download me-1" viewBox="0 0 16 16"> <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/> <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/> </svg>
                                 儲存 QR Code
                             </button>
                         </div>
                     </div>
                </div>

                <div id="cloudModeSection" class="mt-4 card" style="display: none;">
                    <div class="card-body">
                        <h3 class="h5 text-warning mb-3">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-exclamation-triangle-fill me-1" viewBox="0 0 16 16"> <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5m.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2"/> </svg>
                            資料量過大，請使用雲端模式
                        </h3>
                        <p class="mb-2">壓縮後的資料大小超過 QR Code 容量上限 (<span id="compressedSizeInfo"></span> bytes)。</p>
                        <p>請將下方 JSON 資料複製並儲存到您選擇的雲端空間（例如：<a href="https://gist.github.com/" target="_blank" rel="noopener noreferrer">GitHub Gist</a>, <a href="https://pastebin.com/" target="_blank" rel="noopener noreferrer">Pastebin</a> 等，**請確保設為公開或擁有連結者可讀**），然後將產生的**原始資料連結 (Raw URL)** 貼回下方。</p>
                        <div class="mb-3">
                            <label for="jsonDataDisplay" class="form-label">完整 JSON 資料:</label>
                            <textarea id="jsonDataDisplay" class="form-control" rows="6" readonly style="height:200px; overflow:auto;"></textarea>
                            <button id="copyJsonButton" class="btn btn-sm btn-outline-secondary mt-2">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard me-1" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0z"/> </svg>
                                複製 JSON
                            </button>
                            <button id="downloadJsonButton" class="btn btn-sm btn-outline-secondary mt-2 ms-2">
                              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download me-1" viewBox="0 0 16 16">
                                <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/>
                                <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/>
                              </svg>
                              下載 JSON (壓縮格式)
                            </button>
                        </div>
                        <div class="mb-3">
                            <label for="cloudUrlInput" class="form-label">貼上您的雲端資料連結 (Raw URL):</label>
                            <input type="url" id="cloudUrlInput" class="form-control" placeholder="例如：https://gist.githubusercontent.com/.../raw/...">
                        </div>
                        <button id="generateLinkQrButton" class="btn btn-primary">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-link-45deg me-1" viewBox="0 0 16 16"> <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1 1 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4 4 0 0 1-.128-1.287z"/> <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243z"/> </svg>
                            使用連結產生 QR Code
                        </button>
                    </div>
                </div>

                <div id="generateMessage" class="alert mt-4 d-none" role="alert"></div>
            </div>

            <div class="tab-pane fade" id="scanTabPane" role="tabpanel" aria-labelledby="scan-tab" tabindex="0">
                 <div class="card mb-4">
                     <div class="card-body text-center">
                        <h3 class="h5 mb-3">掃描 QR Code</h3>
                        <p class="text-muted">將 QR Code 置於下方掃描區域內</p>
                        <div id="reader">
                            <p class="text-muted small">掃描器準備中...</p>
                        </div>
                         <div id="scanMessage" class="alert alert-info mt-3 d-none" role="alert">
                            正在請求相機權限...
                        </div>

                        <div class="mt-3">
                             <label for="loadJsonInputScan" class="btn btn-outline-secondary btn-sm">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-earmark-arrow-up-fill me-1" viewBox="0 0 16 16">
                                   <path d="M9.293 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V4.707A1 1 0 0 0 13.707 4L10 .293A1 1 0 0 0 9.293 0M9.5 3.5v-2l3 3h-2a1 1 0 0 1-1-1M6.354 9.854a.5.5 0 0 1-.708-.708l2-2a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 8.207V12.5a.5.5 0 0 1-1 0V8.207z"/>
                                 </svg>
                                 由此載入 JSON 檔案顯示
                             </label>
                             <input type="file" id="loadJsonInputScan" accept=".json" style="display:none;">
                         </div>
                         </div>
                 </div>

                 <div id="scanResult" class="mt-4 card" style="display: none;">
                     <div class="card-body">
                        <h3 class="h5 mb-3">掃描/載入結果:</h3>
                        <ul id="scanResultList" class="list-group list-group-flush">
                        </ul>
                     </div>
                 </div>

            </div>
            
            <div class="tab-pane fade" id="helpTabPane" role="tabpanel" aria-labelledby="help-tab" tabindex="0">
                <div class="p-3">

                  <h4 class="mb-3">🛠️ 功能快速導覽</h4>
                  <ol class="ps-3">
                    <li><strong>填寫表單 → 產生 QR</strong>
                        <ul>
                          <li>輸入茶葉或商品資料、可選圖片。</li>
                          <li>按 <kbd>產生 QR</kbd>：<br>
                              ▸ 資料量在 QR 容量內 → 直接產生 <em>單張</em> QR (內嵌壓縮資料)。<br>
                              ▸ 超出容量 → 進入「雲端模式」，顯示原始 JSON，並引導您上傳到雲端（Pastebin、Gist…），再將雲端連結貼回產生 QR。</li>
                        </ul>
                    </li>

                    <li><strong>複製／下載 JSON</strong>
                        <ul>
                          <li><kbd>複製 JSON</kbd>：將表單內容轉換的 <em>原始明碼</em> JSON 複製到剪貼簿（用於雲端模式上傳）。</li>
                          <li><kbd>下載 JSON (壓縮格式)</kbd>：下載 <em>壓縮後</em> 的最小 JSON（結構 <code>{v:1,d:"…"}</code>），此格式也可透過「載入 JSON」還原。</li>
                        </ul>
                    </li>

                    <li><strong>掃描 QR 或載入檔案還原</strong>
                        <ul>
                          <li><strong>掃描 QR：</strong>支援<br>
                              ▸ 內嵌壓縮字串<br>
                              ▸ 內嵌 <code>{v:1,d:"…"}</code> 最小 JSON<br>
                              ▸ 指向雲端 JSON 的 <code>http / https</code> 連結。</li>
                          <li><strong>載入 QR Code (圖片檔)：</strong> 點擊 <kbd>載入 QR Code</kbd> 選擇圖片檔，程式會自動掃描並將資料填入「產生」頁籤的表單。</li>
                          <li><strong>載入 JSON (檔案)：</strong> 點擊 <kbd>載入 JSON</kbd> 選擇 <code>.json</code> 檔案（支援原始明碼或 <code>{v:1,d:"…"}</code> 壓縮格式），程式會將資料填入「產生」頁籤的表單。</li>
                          <li><strong>雲端連結處理：</strong> 若掃描到 URL，程式會嘗試自動抓取。若無法連線 / CORS 受阻 → 介面會顯示下載連結，請先存檔，再用 <kbd>載入 JSON</kbd> 按鈕匯入。</li>
                        </ul>
                    </li>
                  </ol>

                  <hr>

                  <h4 class="mb-3">🔒 安全性與隱私</h4>
                  <ul class="list-unstyled ps-3">
                    <li>✅ <strong>本地處理：</strong>表單資料、壓縮／解壓、QR 產生與掃描均在瀏覽器內執行，不上傳到伺服器。</li>
                    <li>✅ <strong>圖片 Base64 嵌入：</strong>圖片轉 Base64 後寫入 JSON，可離線顯示；若擔心體積，可改用外部 URL。</li>
                    <li>⚠️ <strong>雲端模式：</strong>只有您 <em>自行</em> 上傳 JSON 至第三方（Gist、Pastebin 等）時，資料才會離開本機。請注意您所選用雲端服務的隱私政策。</li>
                    <li>✅ <strong>壓縮隱碼：</strong>壓縮＋Base64 後的字串無法直接閱讀，可降低誤曝光風險，但非加密。</li>
                    <li>✅ <strong>原始碼可檢閱：</strong>整頁為單檔前端，無任何隱藏 API；可離線保存後使用。</li>
                  </ul>

                  <hr>

                  <h4 class="mb-3">❓ 常見問題 (FAQ)</h4>
                  <dl>
                    <dt>Q. 為何「資料過大」會跳到雲端模式？</dt>
                    <dd>QR Code 最大容量約 2,953 bytes（Version 40-M）。超過後掃描成功率低，改用雲端 JSON 連結最穩定。</dd>

                    <dt>Q. 掃描後只看到 <code>{v:1,d:"…"}</code> ？</dt>
                    <dd>那是壓縮包。若自動解壓失敗（例如手動複製貼上），可將其存成 <code>.json</code> 檔 → 按 <kbd>載入 JSON</kbd> 還原。</dd>

                    <dt>Q. 下載的 JSON 檔案大小比原始 JSON 大？</dt>
                    <dd>下載的 <code>{v:1,d:"..."}</code> 格式 JSON 檔，其 <code>d</code> 部分是 Base64 編碼，會比原始二進位壓縮資料大約 33%。但 QR Code 內部儲存的是更緊湊的二進位資料，並無此膨脹問題。</dd>

                    <dt>Q. 這個工具可以離線用嗎？</dt>
                    <dd>可以。將此 <code>index.html</code> 檔案儲存到您的電腦，直接用瀏覽器打開即可。所有核心功能（產生、壓縮、解壓、掃描檔案、載入檔案）皆可離線運作。唯獨「相機掃描」和「抓取雲端 URL」需要網路連線和瀏覽器權限。</dd>
                  </dl>

                  <hr>

                  <h4 class="mb-3">🆘 疑難排解</h4>
                  <ul>
                    <li><strong>掃不到 QR：</strong>確定相機對焦、環境光充足；若圖案過密，嘗試把螢幕亮度調高或打印放大。</li>
                    <li><strong>Fetch 失敗 (CORS)：</strong>瀏覽器基於安全策略阻擋跨域請求；請點擊掃描結果訊息中的「下載檔案」連結，手動下載後再使用 <kbd>載入 JSON</kbd> 匯入。</li>
                    <li><strong>圖片過大：</strong>建議對 JPG/PNG 先壓縮至 <em>&lt;300 kB</em>，或改用外部圖片 URL 以減小 QR Code 資料量。Base64 圖片會顯著增加 JSON 大小。</li>
                    <li><strong>無法啟動相機：</strong>請檢查瀏覽器是否已授予此頁面相機權限。可能需要重新整理頁面或在瀏覽器設定中調整。</li>
                  </ul>

                  <p class="text-muted small mt-4">
                    最後更新：2025-05-04 | © 2025 <em>cypswu</em>
                  </p>

                </div>
                </div>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

    <script>
        // --- Configuration ---
        const fieldConfig = [
            // 基本資訊 (Basic)
            { id: 'teaName', label: '品名', section: 'basic', placeholder: '例如：阿里山金萱', type: 'text', col: 'col-md-6' },
            { id: 'teaType', label: '茶類', section: 'basic', placeholder: '例如：烏龍茶', type: 'text', col: 'col-md-6' },
            { id: 'cultivar', label: '品種', section: 'basic', placeholder: '例如：金萱 (台茶12號)', type: 'text', col: 'col-md-6' },
            { id: 'originRegion', label: '產地', section: 'basic', placeholder: '例如：台灣嘉義縣阿里山鄉', type: 'text', col: 'col-md-6' },
            { id: 'producer', label: '生產者/茶廠', section: 'basic', placeholder: '例如：XX茶業', type: 'text', col: 'col-md-6' },
            { id: 'altitude', label: '海拔 (公尺)', section: 'basic', placeholder: '例如：1200', type: 'number', col: 'col-md-6' },
            { id: 'harvestDate', label: '採收日期', section: 'basic', placeholder: '', type: 'date', col: 'col-md-6' },
            { id: 'harvestSeason', label: '採收季節', section: 'basic', placeholder: '例如：春季', type: 'text', col: 'col-md-6' },
            // 常用資訊 (Common)
            { id: 'grade', label: '等級', section: 'common', placeholder: '例如：特級', type: 'text', col: 'col-md-4' },
            { id: 'batchNo', label: '批號', section: 'common', placeholder: '例如：202405A', type: 'text', col: 'col-md-4' },
            { id: 'netWeight', label: '淨重 (克/兩)', section: 'common', placeholder: '例如：2兩', type: 'text', col: 'col-md-4' },
            { id: 'teaMaster', label: '製茶師', section: 'common', placeholder: '例如：王小明', type: 'text', col: 'col-md-4' },
            { id: 'packagingDate', label: '包裝日期', section: 'common', placeholder: '', type: 'date', col: 'col-md-4' },
            { id: 'shelfLife', label: '保存期限', section: 'common', placeholder: '例如：2年', type: 'text', col: 'col-md-4' },
            { id: 'flavorNotes', label: '風味描述', section: 'common', placeholder: '例如：帶有奶香、花香，口感滑順', type: 'textarea', col: 'col-md-6' },
            { id: 'brewGuide', label: '沖泡建議', section: 'common', placeholder: '例如：水溫95°C，第一泡60秒...', type: 'textarea', col: 'col-md-6' },
            { id: 'storagePack', label: '保存方式/包裝', section: 'common', placeholder: '例如：真空包裝，存放於陰涼乾燥處', type: 'text', col: 'col-md-6' },
            { id: 'certification', label: '認證標章', section: 'common', placeholder: '例如：SGS 認證、有機認證', type: 'text', col: 'col-md-6' },
            { id: 'priceTWD', label: '參考售價 (TWD)', section: 'common', placeholder: '例如：800', type: 'text', col: 'col-md-4' },
            { id: 'barcode', label: '商品條碼', section: 'common', placeholder: '例如：471xxxxxxxxxx', type: 'text', col: 'col-md-4' },
            { id: 'productImageUrl', label: '商品圖片網址', section: 'common', placeholder: 'https://...', type: 'url', col: 'col-md-12' },
            { id: 'productImageFile', label: '上傳商品圖片', section: 'common', type: 'file', col: 'col-md-6' }, // Keep col-md-6 for layout
            { id: 'productImageFilePreview', label: '', section: 'common', type: 'preview', col: 'col-md-6' }, // Placeholder for preview area positioning
            { id: 'notes', label: '備註', section: 'common', placeholder: '其他補充資訊', type: 'textarea', col: 'col-md-12' },
            // 進階資訊 (Advance)
            { id: 'gardenArea', label: '茶園面積', section: 'advance', placeholder: '例如：5公頃', type: 'text', col: 'col-md-4' },
            { id: 'farmingMethod', label: '耕作方式', section: 'advance', placeholder: '例如：有機農法、自然農法', type: 'text', col: 'col-md-4' },
            { id: 'fermentation', label: '發酵程度 (%)', section: 'advance', placeholder: '例如：20', type: 'text', col: 'col-md-4' },
            { id: 'roastLevel', label: '焙火程度', section: 'advance', placeholder: '例如：輕焙火、中焙火', type: 'text', col: 'col-md-4' },
            { id: 'treeAge', label: '茶樹樹齡', section: 'advance', placeholder: '例如：30年', type: 'text', col: 'col-md-4' },
            { id: 'liquorColor', label: '茶湯色澤', section: 'advance', placeholder: '例如：金黃明亮', type: 'text', col: 'col-md-4' },
            { id: 'leafAppearance', label: '葉底外觀', section: 'advance', placeholder: '例如：葉片完整，葉緣鑲紅邊', type: 'text', col: 'col-md-6' },
            { id: 'climate', label: '氣候條件', section: 'advance', placeholder: '例如：雲霧繚繞，日夜溫差大', type: 'text', col: 'col-md-6' },
            { id: 'clarity', label: '茶湯澄清度', section: 'advance', placeholder: '例如：清澈透亮', type: 'text', col: 'col-md-4' },
            { id: 'brokenRate', label: '碎末率 (%)', section: 'advance', placeholder: '例如：< 5', type: 'text', col: 'col-md-4' },
            { id: 'moisture', label: '含水量 (%)', section: 'advance', placeholder: '例如：< 7', type: 'text', col: 'col-md-4' },
            { id: 'phValue', label: 'pH值', section: 'advance', placeholder: '例如：5.5', type: 'number', step: '0.1', col: 'col-md-6' },
            { id: 'caffeine', label: '咖啡因含量', section: 'advance', placeholder: '例如：中等', type: 'text', col: 'col-md-6' },
            // 專家資訊 (Expert)
            { id: 'pesticideReport', label: '農藥檢測報告', section: 'expert', placeholder: '例如：SGS 檢測連結或摘要', type: 'textarea', col: 'col-md-12' },
            { id: 'equipment', label: '使用設備', section: 'expert', placeholder: '例如：特殊製茶設備說明', type: 'textarea', col: 'col-md-12' },
            { id: 'awards', label: '得獎紀錄', section: 'expert', placeholder: '例如：2023年 XX 比賽金獎', type: 'textarea', col: 'col-md-12' },
        ];

        const sections = {
            basic: { title: '基本資訊', fields: [], element: null },
            common: { title: '常用資訊', fields: [], element: null },
            advance: { title: '進階資訊', fields: [], element: null },
            expert: { title: '專家資訊', fields: [], element: null },
        };

        const MAX_QR_LENGTH = 2953; // QR Code Version 40, Level M max bytes (approx for alphanumeric)

        // --- DOM Elements ---
        const teaForm = document.getElementById('teaForm');
        const teaFormAccordion = document.getElementById('teaFormAccordion');
        const qrCodeResultDiv = document.getElementById('qrCodeResult');
        const qrCanvas = document.getElementById('qrCanvas');
        const qrCodeImageContainer = document.getElementById('qrCodeImageContainer');
        const saveQrButton = document.getElementById('saveQrButton');
        const loadQrInput = document.getElementById('loadQrInput');
        const loadJsonInput = document.getElementById('loadJsonInput');
        const generateMessageDiv = document.getElementById('generateMessage');
        const scanMessageDiv = document.getElementById('scanMessage');
        const scanResultDiv = document.getElementById('scanResult');
        const scanResultList = document.getElementById('scanResultList');
        const readerDiv = document.getElementById('reader');
        const generateTab = document.getElementById('generate-tab');
        const scanTab = document.getElementById('scan-tab');
        const loadJsonInputScan = document.getElementById('loadJsonInputScan');
        const cloudModeSection = document.getElementById('cloudModeSection');
        const jsonDataDisplay = document.getElementById('jsonDataDisplay');
        const copyJsonButton = document.getElementById('copyJsonButton');
        const downloadJsonButton = document.getElementById('downloadJsonButton');
        const cloudUrlInput = document.getElementById('cloudUrlInput');
        const generateLinkQrButton = document.getElementById('generateLinkQrButton');
        const compressedSizeInfo = document.getElementById('compressedSizeInfo');

        let html5QrCode = null; // Scanner instance
        let currentQrData = null; // To store data for saving QR
        let currentQrDataType = 'canvas'; // 'canvas', 'image' (Currently always canvas)
        let productImageBase64 = null; // To store uploaded image data as base64 string

        // --- Utility Functions ---

        /**
         * 顯示訊息
         * @param {HTMLElement} element - 顯示訊息的元素
         * @param {string} message - 訊息內容 (允許 HTML)
         * @param {string} type - 訊息類型 (success, danger, warning, info)
         */
        function showMessage(element, message, type = 'info') {
            element.className = `alert alert-${type} mt-3`; // Keep margin
            element.innerHTML = message; // Use innerHTML to allow basic formatting (like links)
            element.style.display = 'block';
            // console.log(`[Message ${type}]: ${message.replace(/<[^>]*>/g, '')}`); // Log plain text version
        }

        /**
         * 隱藏訊息
         * @param {HTMLElement} element - 隱藏訊息的元素
         */
        function hideMessage(element) {
            element.style.display = 'none';
            element.textContent = '';
        }

        /**
         * 將 File 物件讀取為 Base64 字串 (Data URL)
         * @param {File} file - 要讀取的檔案
         * @returns {Promise<string>} - Base64 Data URL 字串的 Promise
         */
        function readFileAsBase64(file) {
             // console.log(`[Debug] Reading file: ${file.name}, size: ${file.size}, type: ${file.type}`);
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                     // console.log("[Debug] File read successfully as Base64.");
                    resolve(reader.result); // reader.result contains the Data URL (e.g., "data:image/jpeg;base64,...")
                }
                reader.onerror = (error) => {
                     console.error("[Error] File reading error:", error);
                    reject(error);
                }
                reader.readAsDataURL(file);
            });
        }

        // --- Core Application Logic ---

        /**
         * 根據 fieldConfig 動態產生表單欄位和 Accordion
         */
        function generateFormFields() {
            // console.log("[Debug] Generating form fields...");
            // 1. 將欄位分配到各個 section
            fieldConfig.forEach(field => {
                if (sections[field.section] && field.type !== 'preview') { // Exclude preview placeholders
                    sections[field.section].fields.push(field);
                }
            });

            // 2. 為每個 section 產生 Accordion Item
            Object.keys(sections).forEach((key, index) => {
                const section = sections[key];
                if (section.fields.length === 0) return; // Skip sections with no fields

                const accordionItemId = `accordion-${key}`;
                const headerId = `header-${key}`;
                const collapseId = `collapse-${key}`;

                const accordionItem = document.createElement('div');
                accordionItem.className = 'accordion-item';
                sections[key].element = accordionItem; // Store reference

                const accordionHeader = document.createElement('h2');
                accordionHeader.className = 'accordion-header';
                accordionHeader.id = headerId;

                const accordionButton = document.createElement('button');
                accordionButton.className = `accordion-button ${index === 0 ? '' : 'collapsed'}`; // First section expanded by default
                accordionButton.type = 'button';
                accordionButton.dataset.bsToggle = 'collapse';
                accordionButton.dataset.bsTarget = `#${collapseId}`;
                accordionButton.ariaExpanded = index === 0 ? 'true' : 'false';
                accordionButton.ariaControls = collapseId;
                accordionButton.textContent = section.title;

                accordionHeader.appendChild(accordionButton);

                const accordionCollapse = document.createElement('div');
                accordionCollapse.id = collapseId;
                accordionCollapse.className = `accordion-collapse collapse ${index === 0 ? 'show' : ''}`;
                accordionCollapse.ariaLabelledby = headerId;
                // accordionCollapse.dataset.bsParent = '#teaFormAccordion'; // Removed to allow multiple open

                const accordionBody = document.createElement('div');
                accordionBody.className = 'accordion-body';

                const row = document.createElement('div');
                row.className = 'row g-3'; // g-3 for gutters

                // 3. 在 Accordion Body 中產生欄位
                section.fields.forEach(field => {
                    const colDiv = document.createElement('div');
                    colDiv.className = field.col || 'col-12';

                    const label = document.createElement('label');
                    label.htmlFor = field.id;
                    label.className = 'form-label';
                    label.textContent = field.label;

                    let inputElement;
                    if (field.type === 'textarea') {
                        inputElement = document.createElement('textarea');
                        inputElement.rows = 3;
                        inputElement.id = field.id;
                        inputElement.name = field.id;
                        inputElement.className = 'form-control';
                        if (field.placeholder) inputElement.placeholder = field.placeholder;
                        colDiv.appendChild(label);
                        colDiv.appendChild(inputElement);

                    } else if (field.type === 'file') {
                        inputElement = document.createElement('input'); // The hidden actual input
                        inputElement.type = 'file';
                        inputElement.accept = 'image/*';
                        inputElement.id = field.id;
                        inputElement.name = field.id; // Important for FormData

                        const fileLabelButton = document.createElement('label'); // The visible button
                        fileLabelButton.htmlFor = field.id;
                        fileLabelButton.className = 'btn btn-sm custom-file-upload'; // Use custom class
                        fileLabelButton.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image me-1" viewBox="0 0 16 16"> <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0"/> <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1z"/> </svg>
                            選擇圖片`;

                        const fileNameSpan = document.createElement('span'); // To display filename
                        fileNameSpan.id = `${field.id}Name`; // ID for filename display
                        fileNameSpan.className = 'file-name-display ms-2'; // Add margin start

                        const previewDiv = document.createElement('div'); // Preview container
                        previewDiv.id = `${field.id}Preview`;
                        previewDiv.className = 'mt-2'; // Add margin top

                        colDiv.appendChild(label);
                        colDiv.appendChild(document.createElement('br')); // Line break for better layout
                        colDiv.appendChild(fileLabelButton);
                        colDiv.appendChild(fileNameSpan);
                        colDiv.appendChild(inputElement); // Append hidden input
                        colDiv.appendChild(previewDiv); // Append preview container

                        // Event listener for file selection
                        inputElement.addEventListener('change', async (event) => {
                           const file = event.target.files[0];
                           previewDiv.innerHTML = ''; // Clear previous preview
                           fileNameSpan.textContent = ''; // Clear filename
                           productImageBase64 = null; // Clear stored base64
                           if (file) {
                                fileNameSpan.textContent = file.name; // Show filename
                                try {
                                    productImageBase64 = await readFileAsBase64(file);
                                    // console.log(`[Debug] Read Base64 for preview, length: ${productImageBase64.length}`);
                                    const img = document.createElement('img');
                                    img.src = productImageBase64;
                                    img.alt = '圖片預覽';
                                    // Styles moved to CSS (#productImageFilePreview img)
                                    previewDiv.appendChild(img);
                                } catch (error) {
                                    console.error("無法讀取檔案:", error);
                                    showMessage(generateMessageDiv, '無法讀取圖片檔案。', 'danger');
                                    fileNameSpan.textContent = '讀取失敗';
                                }
                           }
                        });

                    } else { // Handles text, number, date, url etc.
                        inputElement = document.createElement('input');
                        inputElement.type = field.type;
                         if (field.step) inputElement.step = field.step;
                        inputElement.id = field.id;
                        inputElement.name = field.id;
                        inputElement.className = 'form-control';
                        if (field.placeholder) inputElement.placeholder = field.placeholder;
                        colDiv.appendChild(label);
                        colDiv.appendChild(inputElement);
                    }

                    row.appendChild(colDiv);
                });

                accordionBody.appendChild(row);
                accordionCollapse.appendChild(accordionBody);
                accordionItem.appendChild(accordionHeader);
                accordionItem.appendChild(accordionCollapse);
                teaFormAccordion.appendChild(accordionItem);
            });
            // console.log("[Debug] Form fields generated.");
        }

        /**
         * 將 QR Canvas 與茶名合併輸出成新 Canvas
         * @param {HTMLCanvasElement} srcCanvas - 既有的 QR Canvas
         * @param {string} caption   - 要顯示的茶名
         * @returns {HTMLCanvasElement}
         */
        function buildQrWithCaptionCanvas(srcCanvas, caption) {
          const fontSize   = 24;           // 字體大小 (px)
          const paddingTop = 12;           // 文字與 QR 的間距
          const extraH     = caption ? fontSize + paddingTop * 2 : 0;

          const c = document.createElement('canvas');
          c.width  = srcCanvas.width;
          c.height = srcCanvas.height + extraH;

          const ctx = c.getContext('2d');
          ctx.fillStyle = '#fff';
          ctx.fillRect(0, 0, c.width, c.height);        // 白底
          ctx.drawImage(srcCanvas, 0, 0);               // 畫 QR

          if (caption) {
            ctx.font = `bold ${fontSize}px "Noto Sans", sans-serif`;
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(caption, c.width / 2, srcCanvas.height + paddingTop);
          }
          return c;
        }
        
        /**
         * 產生 QR Code (使用 Canvas)
         * @param {string} data - 要編碼的資料 (壓縮後的 Base64 字串或 URL)
         * @param {boolean} isUrl - 標示 data 是否為 URL (目前主要影響 log)
         */
        function displayQrCode(data, isUrl = false) {
            hideMessage(generateMessageDiv);
            cloudModeSection.style.display = 'none';
            qrCodeImageContainer.innerHTML = ''; // Clear previous image QR (if any)
            qrCanvas.style.display = 'none'; // Hide canvas initially

            // console.log(`[Debug] Generating QR Code. Is URL: ${isUrl}, Data: ${isUrl ? data : data.substring(0, 50) + '...'}`);

            try {
                currentQrData = data; // Store data for saving
                currentQrDataType = 'canvas'; // Always use canvas for generation

                qrCanvas.style.display = 'block';
                new QRious({
                    element: qrCanvas,
                    value: data,
                    size: 420, // Match canvas dimensions
                    level: 'M', // Error correction level (L, M, Q, H)
                    padding: 20, // Padding around the QR code (pixels)
                    background: 'white',
                    foreground: 'black'
                });

                qrCodeResultDiv.style.display = 'block';
                // 更新畫面上的茶名
                const captionEl = document.getElementById('qrTeaName');
                if (captionEl) {
                  const teaNameTxt = document.getElementById('teaName')?.value.trim();
                  if (teaNameTxt) {
                      captionEl.textContent = teaNameTxt;
                      captionEl.style.display = 'block';
                  } else {
                      captionEl.style.display = 'none';
                  }
                }
                qrCodeResultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                // console.log("[Debug] QR Code generated successfully on canvas.");

            } catch (error) {
                console.error("QR Code 產生失敗:", error);
                showMessage(generateMessageDiv, `QR Code 產生失敗: ${error.message}`, 'danger');
                qrCodeResultDiv.style.display = 'none';
            }
        }

        /**
         * 處理表單提交事件
         */
        async function handleFormSubmit(event) {
            event.preventDefault();
            // console.log("[Debug] Form submitted.");
            hideMessage(generateMessageDiv);
            qrCodeResultDiv.style.display = 'none';
            cloudModeSection.style.display = 'none';

            const formData = new FormData(teaForm);
            const teaData = {};

            // 收集表單數據
            fieldConfig.forEach(field => {
                if (field.type !== 'file' && field.type !== 'preview') { // Exclude file input and preview placeholder
                    const value = formData.get(field.id);
                    if (value !== null && value !== '') { // Only store non-empty values
                       teaData[field.id] = value;
                       // console.log(`[Debug] Form Data: ${field.id} = ${value}`);
                    }
                }
            });

            // 處理圖片：優先使用上傳的檔案 (Base64 Data URL)
            if (productImageBase64) {
                teaData.productImageBase64 = productImageBase64; // Store the Base64 Data URL
                // console.log(`[Debug] Using uploaded image Base64 (length: ${productImageBase64.length})`);
                // If Base64 exists, remove the URL field value to avoid redundancy
                if (teaData.productImageUrl) {
                    // console.log(`[Debug] Removing productImageUrl (${teaData.productImageUrl}) because Base64 exists.`);
                    delete teaData.productImageUrl;
                    const urlInput = document.getElementById('productImageUrl');
                    if(urlInput) urlInput.value = ''; // Clear the input field visually
                }
            } else if (teaData.productImageUrl) {
                // console.log(`[Debug] Using productImageUrl: ${teaData.productImageUrl}`);
                // Keep the URL if no Base64 is present
            }

            // Remove potentially empty placeholder fields if needed (e.g., productImageFile)
            delete teaData.productImageFile; // This field itself doesn't hold the value

            if (Object.keys(teaData).length === 0) {
                showMessage(generateMessageDiv, '請至少填寫一項資訊。', 'warning');
                return;
            }

            try {
                const jsonString = JSON.stringify(teaData);
                // console.log("[Debug] Original JSON String:", jsonString.substring(0, 200) + '...'); // Log beginning

                const compressedData = LZString.compressToBase64(jsonString);
                const compressedLength = compressedData.length;
                // console.log("[Debug] Compressed Base64:", compressedData.substring(0, 100) + '...'); // Log beginning
                // console.log("[Debug] Compressed Length:", compressedLength);

                if (compressedLength <= MAX_QR_LENGTH) {
                    // --- Direct Mode ---
                    // console.log("[Debug] Data fits in QR Code (Direct Mode).");
                    displayQrCode(compressedData, false);
                } else {
                    // --- Cloud Mode ---
                    // console.log("[Debug] Data too large for QR Code (Cloud Mode).");
                    compressedSizeInfo.textContent = compressedLength; // Show compressed size
                    showMessage(generateMessageDiv, `資料量過大 (${compressedLength} > ${MAX_QR_LENGTH} bytes)，請使用雲端模式。`, 'warning');
                    jsonDataDisplay.value = jsonString; // Display full JSON for copying
                    cloudUrlInput.value = ''; // Clear URL input
                    cloudModeSection.style.display = 'block';
                    qrCodeResultDiv.style.display = 'none';
                    cloudModeSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }

            } catch (error) {
                console.error("處理表單資料時發生錯誤:", error);
                showMessage(generateMessageDiv, `處理資料時發生錯誤: ${error.message}`, 'danger');
            }
        }

        /**
         * 處理儲存 QR Code 按鈕點擊事件（結合 File System Access API 與 <a download> fallback）
         */
        async function handleSaveQr() {
            if (!currentQrData) {
                showMessage(generateMessageDiv, '沒有可儲存的 QR Code。', 'warning');
                return;
            }
            // console.log("[Debug] 開始儲存 QR Code...");

            // 1. 建議檔名（來自茶名）
            const teaName = document.getElementById('teaName')?.value.trim();
            const baseName = `tea_${teaName ? teaName.replace(/[\\/:*?"<>|]/g, '') : 'unknown'}`;
            const suggestedName = baseName + '.png';

            // 如果支援 File System Access API，就用原生對話框
            if (window.showSaveFilePicker) {
                try {
                    // console.log("[Debug] 使用 File System Access API 儲存");
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName,
                        types: [{
                            description: 'PNG 圖片',
                            accept: { 'image/png': ['.png'] }
                        }]
                    });
                    const writable = await fileHandle.createWritable();

                    // 取得 Blob (Always from canvas in current implementation)
                    const composite = buildQrWithCaptionCanvas(qrCanvas, teaName);
                    let blob = await new Promise(res => composite.toBlob(res, 'image/png'));                    
                    // else if (currentQrDataType === 'image' && qrCodeImageContainer.firstChild) { // Fallback if image was used
                    //     const resp = await fetch(qrCodeImageContainer.firstChild.src);
                    //     blob = await resp.blob();
                    // }

                    if (!blob) throw new Error('無法取得 QR Code 圖片資料');

                    await writable.write(blob);
                    await writable.close();

                    showMessage(generateMessageDiv, `QR Code (${fileHandle.name}) 已成功儲存。`, 'success');
                    // console.log("[Debug] File System Access API 儲存完成");
                } catch (e) {
                    if (e.name === 'AbortError') {
                        // console.log("[Debug] 使用者取消儲存");
                        // No message needed if user cancelled
                    } else {
                        console.error("儲存失敗 (File System API)：", e);
                        showMessage(generateMessageDiv, '儲存失敗，請稍後再試或嘗試其他瀏覽器。', 'danger');
                    }
                }

            // fallback: 傳統 <a download> + prompt()
            } else {
                // console.log("[Debug] 使用 <a download> fallback 儲存");
                // 2. 詢問使用者檔名
                const inputName = prompt('請輸入要儲存的檔名（不含副檔名）', baseName);
                if (!inputName) {
                    // console.log("[Debug] 使用者取消檔名輸入");
                    return;
                }
                const filename = inputName.endsWith('.png') ? inputName : inputName + '.png';

                // 3. 產生 data URL (Always from canvas)
                let dataUrl;
                if (currentQrDataType === 'canvas' && qrCanvas) {
                    try {
                        dataUrl = buildQrWithCaptionCanvas(qrCanvas, teaName).toDataURL('image/png');
                    } catch (e) {
                        console.error("從 Canvas 匯出失敗：", e);
                        showMessage(generateMessageDiv, '無法從 Canvas 匯出 QR Code。', 'danger');
                        return;
                    }
                // } else if (currentQrDataType === 'image' && qrCodeImageContainer.firstChild) { // Fallback
                //     dataUrl = qrCodeImageContainer.firstChild.src;
                } else {
                    showMessage(generateMessageDiv, '找不到有效的 QR Code 來源。', 'warning');
                    return;
                }

                // 4. 觸發下載
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showMessage(generateMessageDiv, `QR Code (${filename}) 已開始下載。`, 'success');
                // console.log("[Debug] <a download> fallback 儲存完成");
            }
        }

        /**
         * 處理複製 JSON 按鈕點擊事件 (Copies raw JSON from textarea)
         */
        function handleCopyJson() {
            if (!jsonDataDisplay.value) return;
            jsonDataDisplay.select();
            jsonDataDisplay.setSelectionRange(0, 99999); // For mobile devices
            try {
                // Use Clipboard API for modern browsers
                navigator.clipboard.writeText(jsonDataDisplay.value).then(() => {
                    // console.log("[Debug] JSON copied to clipboard (Clipboard API).");
                    showMessage(generateMessageDiv, '原始 JSON 已複製到剪貼簿。', 'success');
                }).catch(err => {
                     // console.warn("[Debug] Clipboard API failed, falling back to execCommand:", err);
                     // Fallback for older browsers (less reliable)
                    if(document.execCommand('copy')) {
                        // console.log("[Debug] JSON copied to clipboard (execCommand).");
                        showMessage(generateMessageDiv, '原始 JSON 已複製到剪貼簿。', 'success');
                    } else {
                        throw new Error('execCommand failed');
                    }
                });
            } catch (err) {
                console.error('無法複製 JSON:', err);
                showMessage(generateMessageDiv, '複製 JSON 失敗，請手動選取並複製。', 'danger');
            } finally {
                 // Deselect text after attempt
                 window.getSelection()?.removeAllRanges();
            }
        }

        /**
         * 處理下載 JSON 按鈕點擊事件 (Downloads compressed {v,d} format)
         */
        async function handleDownloadJson() {
          if (!jsonDataDisplay.value) {
            showMessage(generateMessageDiv, '沒有可下載的 JSON 資料 (請先產生 QR Code 或觸發雲端模式)。', 'warning');
            return;
          }

          // 1. 建議檔名（從茶名或固定前綴產生）
          const teaName    = document.getElementById('teaName')?.value.trim();
          const baseName   = `tea_${teaName ? teaName.replace(/[\\/:*?"<>|]/g, '') : 'unknown'}`;
          const suggestedName = baseName + '.json';

          // 2. Blob 準備: 取回 textarea 的原始 JSON，壓縮並包 minimal JSON（加版本號 v）
          const rawJson = jsonDataDisplay.value;
          let payload;
          try {
              const compressed = LZString.compressToBase64(rawJson);
              payload = JSON.stringify({ v: 1, d: compressed });
          } catch (e) {
              console.error("壓縮 JSON 失敗:", e);
              showMessage(generateMessageDiv, '壓縮 JSON 資料失敗。', 'danger');
              return;
          }

          const blob = new Blob([payload], { type: 'application/json;charset=utf-8' }); // Specify charset

          // 3. 如果支援 File System Access API，就用原生儲存對話框
          if (window.showSaveFilePicker) {
            try {
              const handle = await window.showSaveFilePicker({
                suggestedName,
                types: [{
                  description: 'JSON 檔案',
                  accept: { 'application/json': ['.json'] }
                }]
              });
              const writable = await handle.createWritable();
              await writable.write(blob);
              await writable.close();
              showMessage(generateMessageDiv, `壓縮格式 JSON (${handle.name}) 已成功儲存。`, 'success');
              // console.log("[Debug] JSON saved via File System Access API");
              return;
            } catch (e) {
              if (e.name === 'AbortError') {
                // console.log("[Debug] 使用者取消儲存");
                return; // No message needed
              }
              console.error("儲存 JSON 失敗 (File System API)：", e);
              showMessage(generateMessageDiv, 'JSON 儲存失敗，請稍後再試。', 'danger');
              return;
            }
          }

          // 4. fallback：prompt 取檔名 + <a download>
          // console.log("[Debug] 使用 <a download> fallback 儲存 JSON");
          const inputName = prompt('請輸入要儲存的檔名（不含副檔名）', baseName);
          if (!inputName) {
            // console.log("[Debug] 使用者取消檔名輸入");
            return;
          }
          const filename = inputName.endsWith('.json') ? inputName : inputName + '.json';

          const url = URL.createObjectURL(blob);
          const a   = document.createElement('a');
          a.href    = url;
          a.download= filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url); // Clean up object URL

          showMessage(generateMessageDiv, `壓縮格式 JSON (${filename}) 已開始下載。`, 'success');
          // console.log("[Debug] JSON downloaded via <a download> fallback");
        }

        /**
         * 處理使用連結產生 QR Code 按鈕點擊事件
         */
        function handleGenerateLinkQr() {
            const url = cloudUrlInput.value.trim();
            // console.log(`[Debug] Generating QR from link: ${url}`);
            if (!url) {
                showMessage(generateMessageDiv, '請輸入有效的雲端資料連結。', 'warning');
                cloudUrlInput.focus();
                return;
            }
            try {
                 // Basic URL validation (checks format, not reachability)
                 new URL(url);
                 displayQrCode(url, true); // Generate QR code with the URL itself
                 cloudModeSection.style.display = 'none'; // Hide cloud mode section after generating
            } catch (error) {
                 // console.error("[Debug] Invalid URL format:", error);
                 showMessage(generateMessageDiv, '請輸入有效的 URL 格式 (例如 https://...) 。', 'danger');
                 cloudUrlInput.focus();
            }
        }


        /**
         * 解析 QR Code 資料 (可能是壓縮字串、最小 JSON 格式或 URL)
         * @param {string} decodedText - 從 QR Code 掃描到的原始字串
         * @returns {Promise<object>} - 解析後的 JSON 物件 Promise
         */
        async function parseQrData(decodedText) {
            // console.log(`[Debug] Parsing QR Data: ${decodedText.substring(0, 100)}...`);
            const activeTabMessageDiv = document.getElementById('scan-tab').classList.contains('active')
                                      ? scanMessageDiv : generateMessageDiv;

            // 1. 嘗試 minimal-JSON 格式 {v:1, d:"..."} (直接內嵌)
            try {
                const maybeJson = JSON.parse(decodedText);
                if (maybeJson && typeof maybeJson === 'object' && maybeJson.v === 1 && typeof maybeJson.d === 'string') {
                    // console.log('[Debug] Detected embedded minimal-JSON payload, decompressing...');
                    const jsonStr = LZString.decompressFromBase64(maybeJson.d);
                    if (!jsonStr) throw new Error('從 minimal-JSON 解壓失敗 (結果為空)');
                    return JSON.parse(jsonStr); // Return the final data object
                }
            } catch (_) {
                // Not embedded minimal-JSON, continue to next checks
            }

            // 2. URL 模式 (http:// or https://)
            if (decodedText.startsWith('http://') || decodedText.startsWith('https://')) {
                // console.log('[Debug] Detected URL, attempting to fetch JSON...');
                showMessage(activeTabMessageDiv, '偵測到 URL，正在擷取雲端資料...', 'info');
                try {
                    const response = await fetch(decodedText, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json, text/plain, */*' },
                        mode: 'cors', // Important for cross-origin requests
                        // Add timeout? Maybe not needed as browser handles it.
                    });

                    if (!response.ok) {
                        // Try to get more info from response if possible
                        let errorText = `伺服器錯誤: ${response.status} ${response.statusText}`;
                        try {
                            const bodyText = await response.text();
                            if (bodyText) errorText += ` - ${bodyText.substring(0, 100)}`;
                        } catch (e) {/* Ignore body read error */}
                        throw new Error(errorText);
                    }

                    const contentType = response.headers.get("content-type");
                    // Check if content type indicates non-JSON data (like HTML)
                    if (contentType && (contentType.includes("text/html") || contentType.includes("application/xml"))) {
                         console.warn(`[Warning] Received non-JSON content type: ${contentType}. URL might be wrong.`);
                         // Throw a specific error for HTML content
                         throw new Error("Expected JSON, but received HTML/XML content.");
                    }

                    // Attempt to parse as JSON
                    const fetchedData = await response.json(); // This will throw SyntaxError if not JSON
                    // console.log('[Debug] Successfully fetched JSON from URL:', fetchedData);

                    // Check if the *fetched* data is minimal-JSON {v,d}
                    if (fetchedData && typeof fetchedData === 'object' && fetchedData.v === 1 && typeof fetchedData.d === 'string') {
                      // console.log('[Debug] Fetched data is minimal-JSON payload, decompressing...');
                      const str = LZString.decompressFromBase64(fetchedData.d);
                      if (!str) throw new Error('從 URL 的 minimal-JSON 解壓後為空');
                      showMessage(activeTabMessageDiv, '已成功從雲端載入並解壓資料。', 'success');
                      return JSON.parse(str); // Return the final data object
                    } else {
                      // Assume fetched data is the final raw JSON object
                      showMessage(activeTabMessageDiv, '已成功從雲端載入資料。', 'success');
                      return fetchedData;
                    }
                } catch (error) {
                    console.error('從 URL 擷取或處理 JSON 失敗:', error);
                    
                    let userMessage = `無法自動擷取資料。請手動下載檔案並使用「載入 JSON」：`; // Default message

                    // Improve error message based on error type
                    const isCorsError = error instanceof TypeError && error.message.toLowerCase().includes('fetch');
                    const isSyntaxError = error instanceof SyntaxError;
                    const receivedHtmlError = error.message && (error.message.includes("Expected JSON, but received HTML/XML content.") || error.message.includes("token '<'"));

                    if (isCorsError) {
                        userMessage = `無法自動擷取資料 (可能為 CORS 跨域限制)。請手動下載檔案並使用「載入 JSON」：`;
                    } else if (receivedHtmlError || isSyntaxError) {
                        userMessage = `無法自動擷取資料：連結未指向有效的 JSON 檔案 (可能為 HTML 頁面或其他格式)。請檢查連結或手動下載檔案並使用「載入 JSON」：`;
                    } else if (error.message) { // Use the original error message for other network/server issues
                         userMessage = `無法自動擷取資料 (${error.message})。請手動下載檔案並使用「載入 JSON」：`;
                    }

                    // Always show the download link attempt
                    // Ensure the link HTML is correctly formed
                    const downloadLinkHtml = `<a href="${decodedText}" target="_blank" rel="noopener noreferrer" class="alert-link">點此嘗試下載檔案</a>`;
                    showMessage(activeTabMessageDiv, `${userMessage} ${downloadLinkHtml}`, 'warning');
                      
                    // Signal upstream to potentially skip redundant error messages
                    throw new Error('manualDownloadRequired');
                }
            }

            // 3. 壓縮字串模式 (Legacy or direct compression)
            // console.log('[Debug] Assuming compressed string, attempting decompression...');
            try {
                const decompressed = LZString.decompressFromBase64(decodedText);
                if (!decompressed) {
                    // This could mean it wasn't Base64 or wasn't compressed with LZString
                    throw new Error('解壓縮後結果為空 (可能非預期格式)');
                }
                // console.log('[Debug] Decompressed successfully');
                return JSON.parse(decompressed); // Parse the decompressed JSON string
            } catch (error) {
                console.error('解壓縮或解析 JSON 失敗:', error);
                // Avoid overwriting the 'manualDownloadRequired' error
                if (error.message === 'manualDownloadRequired') throw error;

                let userFriendlyError = '解碼失敗：資料格式無法識別或已損毀。';
                if (error instanceof SyntaxError) {
                    userFriendlyError = `解碼失敗：JSON 格式錯誤 (${error.message})。`;
                } else if (error.message.includes('解壓縮後結果為空')) {
                    userFriendlyError = '解碼失敗：無法解壓縮資料 (可能非預期格式)。';
                }
                // Add more specific error checks if needed
                throw new Error(userFriendlyError); // Throw a more user-friendly error
            }
        }

        /**
         * 將解析後的資料顯示在掃描結果列表中
         * @param {object} data - 解析後的 JSON 物件
         */
        function displayScanResult(data) {
            // console.log("[Debug] Displaying scan result:", data);
            scanResultList.innerHTML = ''; // Clear previous results
            let hasContent = false;

            // Create a map of field configurations for easier lookup
            const fieldMap = fieldConfig.reduce((map, field) => {
                map[field.id] = field;
                return map;
            }, {});

            // Iterate through the data received from the QR code
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    const field = fieldMap[key]; // Get field config using the key
                    const value = data[key];

                    // Skip empty/null values and the base64 key itself (it's handled separately)
                    if (value === null || value === '' || key === 'productImageBase64') {
                        continue;
                    }

                    const label = field ? field.label : key; // Use config label or key as fallback
                    const type = field ? field.type : 'text'; // Get type from config, default to text

                    let displayValueHtml = '';
                    hasContent = true; // Mark that we have content to display

                    // --- Format value based on type ---
                    if (key === 'productImageUrl' && value) {
                         // console.log(`[Debug] Displaying image from URL: ${value}`);
                         // Display link and image preview with error handling
                         displayValueHtml = `<a href="${value}" target="_blank" rel="noopener noreferrer">${value}</a><br>
                                             <img src="${value}" alt="商品圖片 (URL 載入中...)" class="img-fluid rounded mt-2"
                                                  onerror="this.onerror=null; this.src='https://placehold.co/200x100/eee/ccc?text=無法載入圖片'; this.alt='無法載入圖片';">`;
                    } else if (type === 'textarea' && value) {
                         // console.log(`[Debug] Displaying textarea: ${key}`);
                         // Use <pre> for textareas to preserve line breaks and spacing
                         // Escape HTML content within <pre> to prevent XSS
                         const escapedValue = value.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                         displayValueHtml = `<pre>${escapedValue}</pre>`;
                    } else if (type === 'url' && value && key !== 'productImageUrl') { // Handle other URLs as links
                         // console.log(`[Debug] Displaying URL link: ${key}`);
                         // Ensure URL is properly escaped if needed, though usually href handles it
                         displayValueHtml = `<a href="${value}" target="_blank" rel="noopener noreferrer">${value}</a>`;
                    } else if (type === 'date' && value) {
                        // Optionally format date for display
                        try {
                           displayValueHtml = new Date(value).toLocaleDateString('zh-TW'); // Example: TW locale
                        } catch (e) {
                           displayValueHtml = value; // Fallback to original value if date is invalid
                        }
                    } else {
                        // console.log(`[Debug] Displaying text: ${key} = ${value}`);
                        // Default display: Escape HTML to prevent XSS from text fields
                        displayValueHtml = String(value).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    }

                    // Create and append list item
                    const listItem = document.createElement('li');
                    listItem.className = 'list-group-item';
                    // Use innerHTML carefully, only for trusted label and formatted value
                    listItem.innerHTML = `<strong>${label}:</strong> ${displayValueHtml}`;
                    scanResultList.appendChild(listItem);
                }
            }

             // Specifically check and display Base64 image if it exists
             if (data.productImageBase64) {
                 const field = fieldMap['productImageFile']; // Get the config for the file input
                 const label = field ? field.label : '上傳商品圖片'; // Use its label
                 hasContent = true;
                 const listItem = document.createElement('li');
                 listItem.className = 'list-group-item';
                 // console.log(`[Debug] Displaying image from Base64 (length: ${data.productImageBase64.length}) linked to ${label}`);
                 // Use the Base64 data directly in the src attribute
                 listItem.innerHTML = `<strong>${label}:</strong><br><img src="${data.productImageBase64}" alt="商品圖片 (來自 QR Code)" class="img-fluid rounded mt-2">`;
                 scanResultList.appendChild(listItem);
             }


            // Show or hide the result section based on content
            if (hasContent) {
                scanResultDiv.style.display = 'block';
                scanResultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                 // Final success message already shown by parseQrData or scan success
                 // showMessage(scanMessageDiv, '資料顯示完畢。', 'success');
            } else {
                scanResultDiv.style.display = 'none';
                showMessage(scanMessageDiv, 'QR Code 中沒有找到可顯示的資料。', 'warning');
            }
        }

         /**
         * 將解析後的資料回填到「產生」頁籤的表單中
         * @param {object} data - 解析後的 JSON 物件
         */
        async function populateForm(data) { // Make async if any part needs await
            // console.log("[Debug] Populating form with data:", data);
            try {
                // Reset form and related UI elements first
                teaForm.reset(); // Clear standard form fields
                productImageBase64 = null; // Clear stored Base64 variable

                // Clear file input preview, filename display, and reset button text
                const previewDiv = document.getElementById('productImageFilePreview');
                const fileNameSpan = document.getElementById('productImageFileName'); // Corrected ID usage
                const fileInputButton = document.querySelector('label[for="productImageFile"]'); // The visible button label
                if (previewDiv) previewDiv.innerHTML = '';
                if (fileNameSpan) fileNameSpan.textContent = '';
                if (fileInputButton) { // Reset button to initial state
                    fileInputButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image me-1" viewBox="0 0 16 16"> <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0"/> <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1z"/> </svg>
                        選擇圖片`;
                }
                 // Also clear the hidden file input value itself
                 const fileInput = document.getElementById('productImageFile');
                 if (fileInput) fileInput.value = '';


                let populatedFields = 0;
                // Populate form fields based on the data object
                fieldConfig.forEach(field => {
                    const inputElement = document.getElementById(field.id);
                    if (inputElement) {
                        // Handle file input separately for preview
                        if (field.type === 'file') {
                            // Check if Base64 data exists in the loaded data
                            if (data.productImageBase64) {
                                // console.log(`[Debug] Populating Base64 image preview (length: ${data.productImageBase64.length})`);
                                productImageBase64 = data.productImageBase64; // Store it globally for potential resubmission
                                if (previewDiv) {
                                    const img = document.createElement('img');
                                    img.src = productImageBase64;
                                    img.alt = '載入的圖片';
                                    // Add error handling for Base64 display? Unlikely to fail, but possible.
                                    img.onerror = () => { previewDiv.innerHTML = '<small class="text-danger">無法顯示 Base64 圖片</small>'; };
                                    previewDiv.appendChild(img);
                                }
                                if (fileNameSpan) fileNameSpan.textContent = '已載入圖片 (來自資料)';
                                if (fileInputButton) { // Change button text to indicate loaded image
                                     fileInputButton.innerHTML = `
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle-fill me-1" viewBox="0 0 16 16"> <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/> </svg>
                                        更改圖片`;
                                }
                                populatedFields++;
                             } else if (data.productImageUrl) {
                                 // If only URL exists, populate the URL field, leave file input clear.
                                 // console.log(`[Debug] Image URL found (${data.productImageUrl}), populating URL field.`);
                                 const urlInput = document.getElementById('productImageUrl');
                                 if (urlInput) {
                                     urlInput.value = data.productImageUrl;
                                     populatedFields++; // Count URL field as populated
                                 }
                                 if (fileNameSpan) fileNameSpan.textContent = '圖片使用下方網址';
                             }
                        } else if (field.type !== 'preview') { // Populate regular fields (excluding preview placeholder)
                             if (data[field.id] !== undefined && data[field.id] !== null) {
                                 inputElement.value = data[field.id];
                                 // console.log(`[Debug] Populated field ${field.id} with value: ${data[field.id]}`); // Reduce log verbosity
                                 populatedFields++;
                             } else {
                                 inputElement.value = ''; // Ensure field is cleared if not present in data
                             }
                        }
                    } else {
                        // This case might happen for the 'preview' type placeholder or if ID mismatch
                        if(field.type !== 'preview') {
                            console.warn(`[Warning] Input element not found for field ID: ${field.id} during form population.`);
                        }
                    }
                });

                // console.log(`[Debug] Form population complete. ${populatedFields} fields populated.`);

                // Expand the first accordion section by default after populating
                const firstAccordionButton = teaFormAccordion.querySelector('.accordion-button');
                const firstCollapse = teaFormAccordion.querySelector('.accordion-collapse');
                if (firstAccordionButton && firstCollapse && firstAccordionButton.classList.contains('collapsed')) {
                    // Use Bootstrap's Collapse instance to programmatically show
                    const bsCollapse = bootstrap.Collapse.getOrCreateInstance(firstCollapse);
                    bsCollapse.show();
                    // console.log("[Debug] Expanded first accordion section after population.");
                }

                // Final success message on the generate tab
                showMessage(generateMessageDiv, '已成功從來源載入資料到表單。', 'success');

                // Switch back to the generate tab if not already there
                if (!generateTab.classList.contains('active')) {
                    const bsGenerateTab = bootstrap.Tab.getOrCreateInstance(generateTab);
                    bsGenerateTab.show();
                }

                // Scroll to top smoothly for better UX after loading data
                window.scrollTo({ top: 0, behavior: 'smooth' });

            } catch (error) {
                 console.error("[Error] Error during form population:", error);
                 showMessage(generateMessageDiv, `填充表單時發生錯誤: ${error.message}`, 'danger');
            }
        }


        /**
         * QR Code 掃描成功回調 (From Camera)
         */
        async function onScanSuccess(decodedText, decodedResult) {
            // Check if the scanner instance is still valid (might have been stopped concurrently)
            if (!html5QrCode) {
                 // console.warn("[Debug] Scan success callback triggered, but scanner instance is null. Ignoring.");
                 return; // Prevent processing if scanner was stopped/nulled
            }

            // console.log(`[Debug] QR Scan Success! Raw Text: ${decodedText}`, decodedResult);
            showMessage(scanMessageDiv, `掃描成功！正在處理資料...`, 'info');
            scanResultDiv.style.display = 'none'; // Hide previous results while processing

            // --- Stop Scanner Gracefully ---
            const scannerToStop = html5QrCode; // Keep reference to the active scanner
            html5QrCode = null; // Nullify the global instance immediately to prevent race conditions

            try {
                // Ensure the reader div exists before trying to stop
                if (document.getElementById(scannerToStop.elementId)) {
                    await scannerToStop.stop();
                    // console.log("[Debug] QR Code scanning stopped successfully after scan.");
                    readerDiv.innerHTML = '<p class="text-center text-success p-3">掃描器已停止。</p>';
                } else {
                    // console.warn("[Debug] Reader element not found during stop after scan.");
                }
            } catch (err) {
                 // Log error but continue processing the scanned data
                 console.error("[Error] Error stopping scanner after scan, but continuing processing:", err);
                 readerDiv.innerHTML = '<p class="text-center text-warning p-3">掃描器停止時發生錯誤，但已讀取資料。</p>';
            }
            // --- End Stop Scanner ---


            // --- Process Scanned Data ---
            try {
                const jsonData = await parseQrData(decodedText);
                displayScanResult(jsonData); // Display results on scan tab
            } catch (error) {
                console.error("處理掃描結果失敗:", error);
                // Avoid showing duplicate error if parseQrData already showed 'manualDownloadRequired'
                if (error.message !== 'manualDownloadRequired') {
                    showMessage(scanMessageDiv, `處理掃描結果失敗: ${error.message}`, 'danger');
                }
                scanResultDiv.style.display = 'none'; // Ensure results are hidden on error
                // Offer to rescan
                readerDiv.innerHTML += '<div class="text-center p-2"><button class="btn btn-sm btn-primary mt-2" onclick="startScanner()">重新掃描</button></div>';
            }
            // --- End Process Data ---
        }

        /**
         * QR Code 掃描錯誤回調 (Scanner errors, not decoding errors)
         */
        function onScanFailure(error) {
            // Ignore "No QR code found" which happens frequently and is expected.
            // Log other potential scanner errors.
            if (error && error.message && !error.message.includes("NotFoundException")) {
                 // console.warn(`[Debug] Non-critical scan failure: ${error}`);
                 // Optionally display a subtle message? Usually not needed.
            }
        }


        /**
         * 初始化並啟動相機掃描器
         */
        function startScanner() {
             // console.log("[Debug] Attempting to start scanner...");
             hideMessage(scanMessageDiv);
             scanResultDiv.style.display = 'none'; // Hide previous results
             scanResultList.innerHTML = '';      // Clear previous list items
             readerDiv.innerHTML = '<p class="text-muted small p-3">正在啟動相機...</p>'; // Initial placeholder

             // Prevent starting if already scanning or instance exists but failed previously
             if (html5QrCode && html5QrCode.isScanning) {
                 // console.warn("[Debug] Scanner is already running. Aborting new start request.");
                 return;
             }
             // Clean up any previous instance that might be lingering (e.g., after an error)
             if (html5QrCode) {
                  // console.log("[Debug] Cleaning up previous inactive scanner instance before starting.");
                  // Attempt a clean stop if possible, though it might error if already stopped
                  try { html5QrCode.stop().catch(()=>{}); } catch(e){}
                  html5QrCode = null;
             }

             readerDiv.style.display = 'flex'; // Use flex for centering placeholder initially

             try {
                 // Create a new scanner instance targeting the readerDiv
                 html5QrCode = new Html5Qrcode("reader", { verbose: false }); // verbose: false reduces library logs

                 const config = {
                     fps: 10, // Scan frequency
                     qrbox: (viewfinderWidth, viewfinderHeight) => {
                         // Make QR box responsive, slightly smaller than the narrowest dimension
                         let minEdgePercentage = 0.7; // 70% of the smaller dimension
                         let minEdgeSize = Math.min(viewfinderWidth, viewfinderHeight);
                         let qrboxSize = Math.floor(minEdgeSize * minEdgePercentage);
                         // console.log(`[Debug] Viewfinder: ${viewfinderWidth}x${viewfinderHeight}, QRBox size: ${qrboxSize}`);
                         return { width: qrboxSize, height: qrboxSize };
                     },
                     rememberLastUsedCamera: true, // Try to reuse the last camera
                     supportedScanTypes: [Html5QrcodeScanType.SCAN_TYPE_CAMERA] // Only use camera
                     // aspectRatio: 1.0 // Optional: Force a square aspect ratio for the video feed? Test needed.
                 };

                 showMessage(scanMessageDiv, '正在請求相機權限...', 'info');

                 // Start scanning using the back camera preferentially
                 html5QrCode.start(
                     { facingMode: "environment" }, // Prefer back camera
                     config,
                     onScanSuccess,  // Success callback
                     onScanFailure)  // Failure callback (for scanner errors)
                 .then(() => {
                     // console.log("[Debug] Scanner started successfully.");
                     // Check if the scan tab is still the active one before showing message
                     if (document.getElementById('scan-tab').classList.contains('active')) {
                        showMessage(scanMessageDiv, '相機已啟動，請將 QR Code 對準掃描框。', 'info');
                        readerDiv.style.display = 'block'; // Switch to block display once video starts
                     } else {
                         // If tab changed quickly, stop the scanner we just started
                         // console.log("[Debug] Scan tab was hidden immediately after scanner start, stopping scanner.");
                         stopScanner();
                     }
                 })
                 .catch((err) => {
                     console.error("無法啟動掃描器:", err);
                      // Check if the scan tab is still active before showing the error
                      if (document.getElementById('scan-tab').classList.contains('active')) {
                        let errMsg = `無法啟動相機掃描器: ${err}. 請檢查瀏覽器權限設定，並重新整理頁面嘗試。`;
                        if (String(err).includes('NotAllowedError')) {
                            errMsg = '無法啟動相機：您尚未授予相機權限，或權限已被撤銷。請檢查瀏覽器設定。';
                        } else if (String(err).includes('NotFoundError')) {
                            errMsg = '無法啟動相機：找不到可用的相機設備。';
                        } else if (String(err).includes('NotReadableError')) {
                             errMsg = '無法啟動相機：相機可能正在被其他應用程式使用，或硬體發生問題。';
                        }
                        showMessage(scanMessageDiv, errMsg, 'danger');
                        readerDiv.innerHTML = `<p class="text-center text-danger p-3">無法啟動相機 <br><small>${err}</small></p>`;
                        readerDiv.style.display = 'flex'; // Keep flex for centering error message
                      }
                     html5QrCode = null; // Ensure instance is nulled on error
                 });
             } catch (e) {
                 console.error("初始化 Html5Qrcode 時發生錯誤:", e);
                  if (document.getElementById('scan-tab').classList.contains('active')) {
                    showMessage(scanMessageDiv, `初始化掃描器失敗: ${e}.`, 'danger');
                    readerDiv.style.display = 'flex';
                    readerDiv.innerHTML = `<p class="text-center text-danger p-3">初始化掃描器失敗</p>`;
                  }
                 html5QrCode = null;
             }
        }

         /**
         * 停止相機掃描器 (Gracefully)
         */
        async function stopScanner() {
             // Use the current global instance
             const scannerToStop = html5QrCode;

             if (scannerToStop && scannerToStop.isScanning) {
                 // console.log("[Debug] Attempting to stop scanner manually...");
                 html5QrCode = null; // Nullify global instance first
                 try {
                     // Ensure the target element still exists before calling stop
                     if (document.getElementById(scannerToStop.elementId)) {
                         await scannerToStop.stop();
                         // console.log("[Debug] QR Code scanning stopped successfully via stopScanner().");
                     } else {
                         // console.warn("[Debug] Scanner element not found during manual stop.");
                     }
                 } catch (err) {
                     // Log error, but UI cleanup should still happen
                     console.error("[Error] Error stopping scanner manually:", err);
                 } finally {
                     // Ensure UI is cleared regardless of stop success/failure
                     readerDiv.innerHTML = ''; // Clear reader content
                     hideMessage(scanMessageDiv); // Hide any messages
                 }
             } else {
                 // If instance exists but not scanning, or doesn't exist
                 // console.log("[Debug] stopScanner() called but scanner was not active or found.");
                 readerDiv.innerHTML = ''; // Still clear UI just in case
                 hideMessage(scanMessageDiv);
                 html5QrCode = null; // Ensure nullified
             }
        }


        /**
         * 處理載入 QR Code 檔案輸入事件 (Scans file and Populates Form)
         */
        async function handleLoadQrFile(event) {
            const file = event.target.files[0];
            if (!file) {
                return; // No file selected
            }
            // console.log(`[Debug] Loading QR Code from file: ${file.name}`);

            hideMessage(generateMessageDiv); // Use generate tab's message area
            showMessage(generateMessageDiv, '正在讀取圖片並掃描 QR Code...', 'info');
            loadQrInput.disabled = true; // Disable input while processing

             // Use html5-qrcode to scan the file. Create a temporary instance.
             // We need a temporary visible element for the library, even if we hide it.
             // Let's reuse the readerDiv temporarily, ensuring it's cleared later.
             const tempReaderId = 'reader'; // Use the existing scan tab reader div ID
             const fileScanner = new Html5Qrcode(tempReaderId, { verbose: false });

             try {
                 // Scan the file, don't show the image in the reader element (false)
                 const decodedText = await fileScanner.scanFile(file, /* showImage= */ false);
                 // console.log("[Debug] Scanned successfully from file:", decodedText.substring(0,100) + "...");
                 showMessage(generateMessageDiv, '圖片掃描成功，正在解析資料...', 'info');

                 // Now parse the data and populate the form
                 try {
                     const jsonData = await parseQrData(decodedText);
                     showMessage(generateMessageDiv, '資料解析成功，正在填入表單...', 'info');
                     await populateForm(jsonData); // Populate the form on Generate tab
                     // Success message is shown inside populateForm
                     // console.log("[Debug] Load QR File process completed successfully.");

                 } catch (parseOrPopulateError) {
                     console.error("處理載入的 QR 資料失敗:", parseOrPopulateError);
                     // Provide specific error from parseQrData or populateForm
                     // Avoid showing error if it was 'manualDownloadRequired' (already handled by parseQrData)
                     if (parseOrPopulateError.message !== 'manualDownloadRequired') {
                        showMessage(generateMessageDiv, `處理載入的 QR 資料失敗: ${parseOrPopulateError.message}`, 'danger');
                     }
                 }

             } catch (scanError) {
                 console.error("從檔案掃描失敗:", scanError);
                 let errorMessage = '無法從圖片中掃描到 QR Code。';
                 // Provide more specific error message if available
                 if (scanError && scanError.message) {
                     if (String(scanError).includes("NotFoundException") || String(scanError).includes("No MultiFormat Readers found")) {
                          errorMessage = '圖片中未找到 QR Code 或格式不支援。';
                     } else if (String(scanError).includes("Corrupt")) {
                          errorMessage = '圖片檔案可能已損毀。';
                     }
                      else {
                          errorMessage = `掃描圖片時發生錯誤: ${scanError}`; // Show raw error for debugging
                     }
                 }
                 showMessage(generateMessageDiv, errorMessage, 'danger');
             } finally {
                  // Clean up temporary scanner resources if necessary (library might handle this)
                  try {
                      // Attempt to clear the temporary scanner instance if it has a clear method
                      if (fileScanner && typeof fileScanner.clear === 'function') {
                          // fileScanner.clear(); // As of 2.3.8, clear might not be needed for file scan, but check docs if issues arise
                      }
                  } catch (clearError) {
                      console.warn("Error clearing file scanner instance:", clearError);
                  }
                  // Reset the file input so the same file can be selected again immediately
                  loadQrInput.value = '';
                  loadQrInput.disabled = false; // Re-enable input
                  // Ensure the reader div used temporarily is cleared if it wasn't already
                  // document.getElementById(tempReaderId).innerHTML = ''; // Might interfere with active camera scanner
             }
        }

        /**
         * 處理使用者載入 .json 檔案 (Populates Form)
         */
        function handleLoadJson(event) {
            const file = event.target.files[0];
            if (!file) return;

            // console.log(`[Debug] Loading JSON from file: ${file.name}`);
            hideMessage(generateMessageDiv);
            showMessage(generateMessageDiv, '正在讀取 JSON 檔案...', 'info');
            loadJsonInput.disabled = true;

            const reader = new FileReader();
            reader.onload = async (e) => { // Make async to await populateForm
                try {
                    const text = e.target.result;
                    const parsedJson = JSON.parse(text);

                    let dataToPopulate;
                    // Check if it's the compressed minimal format {v:1, d:"..."}
                    if (parsedJson && typeof parsedJson === 'object' && parsedJson.v === 1 && typeof parsedJson.d === 'string') {
                        // console.log("[Debug] Detected minimal-JSON format in loaded file, decompressing...");
                        const decompressed = LZString.decompressFromBase64(parsedJson.d);
                        if (!decompressed) throw new Error('從檔案解壓縮 minimal-JSON 失敗');
                        dataToPopulate = JSON.parse(decompressed);
                    } else {
                        // Assume it's raw JSON data
                        // console.log("[Debug] Assuming raw JSON format in loaded file.");
                        dataToPopulate = parsedJson;
                    }

                    // Populate the form with the final data object
                    await populateForm(dataToPopulate);
                    // Success message is shown inside populateForm

                } catch (err) {
                    console.error("載入或處理 JSON 檔案失敗:", err);
                    let userMsg = '載入 JSON 失敗：檔案格式錯誤或無法解析。';
                    if (err instanceof SyntaxError) {
                        userMsg = `載入 JSON 失敗：JSON 語法錯誤 (${err.message})。`;
                    } else if (err.message.includes('解壓縮')) {
                        userMsg = `載入 JSON 失敗：${err.message}。`;
                    }
                    showMessage(generateMessageDiv, userMsg, 'danger');
                } finally {
                    // Reset file input regardless of success/failure
                    loadJsonInput.value = '';
                    loadJsonInput.disabled = false;
                }
            };
            reader.onerror = (error) => {
                 console.error("讀取 JSON 檔案時發生錯誤:", error);
                 showMessage(generateMessageDiv, '讀取 JSON 檔案時發生錯誤。', 'danger');
                 loadJsonInput.value = '';
                 loadJsonInput.disabled = false;
            };
            reader.readAsText(file); // Read file as text
        }

        /**
         * 處理在「掃描」頁籤載入 JSON 檔案的事件 (顯示結果於 Scan Tab)
         */
        function handleLoadJsonForScanTab(event) {
            const file = event.target.files[0];
            if (!file) {
                return; // No file selected
            }
            // console.log(`[Debug Scan Tab] Loading JSON from file: ${file.name}`);

            hideMessage(scanMessageDiv); // 使用 Scan Tab 的訊息區
            showMessage(scanMessageDiv, '正在讀取 JSON 檔案...', 'info');
            scanResultDiv.style.display = 'none'; // 隱藏舊結果
            scanResultList.innerHTML = ''; // 清空舊列表
            if (loadJsonInputScan) loadJsonInputScan.disabled = true; // 禁用按鈕

            const reader = new FileReader();

            reader.onload = async (e) => { // Make async if displayScanResult becomes async
                try {
                    const text = e.target.result;
                    let dataToDisplay;

                    // 嘗試解析 JSON (支援原始 JSON 或 壓縮格式 {v:1, d:"..."})
                    const parsedJson = JSON.parse(text);
                    if (parsedJson && typeof parsedJson === 'object' && parsedJson.v === 1 && typeof parsedJson.d === 'string') {
                        // console.log("[Debug Scan Tab] Detected minimal-JSON format in loaded file, decompressing...");
                        const decompressed = LZString.decompressFromBase64(parsedJson.d);
                        if (!decompressed) throw new Error('從檔案解壓縮 minimal-JSON 失敗');
                        dataToDisplay = JSON.parse(decompressed);
                    } else {
                        // console.log("[Debug Scan Tab] Assuming raw JSON format in loaded file.");
                        dataToDisplay = parsedJson; // 假設是原始 JSON
                    }

                    // *** 使用現有的 displayScanResult 函式顯示在第二頁 ***
                    displayScanResult(dataToDisplay);
                    showMessage(scanMessageDiv, '已成功從檔案載入並顯示資料。', 'success');

                } catch (err) {
                    console.error("載入或處理 JSON 檔案失敗 (Scan Tab):", err);
                    let userMsg = '載入 JSON 失敗：檔案格式錯誤或無法解析。';
                    if (err instanceof SyntaxError) {
                        userMsg = `載入 JSON 失敗：JSON 語法錯誤 (${err.message})。`;
                    } else if (err.message && err.message.includes('解壓縮')) {
                        userMsg = `載入 JSON 失敗：${err.message}。`;
                    }
                    showMessage(scanMessageDiv, userMsg, 'danger');
                    scanResultDiv.style.display = 'none'; // 確保出錯時結果區域是隱藏的
                } finally {
                    // Reset file input regardless of success/failure
                    if (loadJsonInputScan) {
                        loadJsonInputScan.value = '';
                        loadJsonInputScan.disabled = false;
                    }
                }
            };

            reader.onerror = (error) => {
                 console.error("讀取 JSON 檔案時發生錯誤 (Scan Tab):", error);
                 showMessage(scanMessageDiv, '讀取 JSON 檔案時發生錯誤。', 'danger');
                 if (loadJsonInputScan) {
                     loadJsonInputScan.value = '';
                     loadJsonInputScan.disabled = false;
                 }
            };

            reader.readAsText(file); // Read file as text
        }        

        // --- Event Listeners Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            // console.log("[Debug] DOMContentLoaded event fired.");
            try {
                generateFormFields(); // Generate form on page load
            } catch (error) {
                console.error("初始化表單欄位時發生錯誤:", error);
                // Display error in a prominent place if form generation fails
                const body = document.querySelector('body');
                if (body) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'alert alert-danger m-3';
                    errorDiv.textContent = `頁面初始化錯誤：無法產生表單欄位 (${error})。請重新整理頁面。`;
                    body.prepend(errorDiv);
                }
            }

            // Attach event listeners only if elements exist
            if (teaForm) {
                teaForm.addEventListener('submit', handleFormSubmit);
            } else { console.error("Error: teaForm element not found."); }

            if (saveQrButton) {
                saveQrButton.addEventListener('click', handleSaveQr);
            } else { console.error("Error: saveQrButton element not found."); }

            if (loadQrInput) {
                loadQrInput.addEventListener('change', handleLoadQrFile);
            } else { console.error("Error: loadQrInput element not found."); }

            if (loadJsonInput) {
                loadJsonInput.addEventListener('change', handleLoadJson);
            } else { console.error("Error: loadJsonInput element not found."); }

            if (copyJsonButton) {
                copyJsonButton.addEventListener('click', handleCopyJson);
            } else { console.error("Error: copyJsonButton element not found."); }

            if (downloadJsonButton) {
                downloadJsonButton.addEventListener('click', handleDownloadJson);
            } else { console.error("Error: downloadJsonButton element not found."); }

             if (generateLinkQrButton) {
                generateLinkQrButton.addEventListener('click', handleGenerateLinkQr);
            } else { console.error("Error: generateLinkQrButton element not found."); }

            if (loadJsonInputScan) {
                loadJsonInputScan.addEventListener('change', handleLoadJsonForScanTab);
            } else { console.error("Error: loadJsonInputScan element not found."); }
            

            // Tab switching logic for scanner activation/deactivation
            const scanTabElement = document.getElementById('scan-tab');
            // const generateTabElement = document.getElementById('generate-tab'); // Not strictly needed for logic

            if (scanTabElement) {
                // When Scan tab becomes visible, start the scanner
                scanTabElement.addEventListener('shown.bs.tab', (event) => {
                    // console.log("[Debug] Scan tab shown.");
                    startScanner();
                });
                 // When Scan tab is *about* to be hidden, stop the scanner
                 scanTabElement.addEventListener('hide.bs.tab', (event) => {
                     // console.log("[Debug] Scan tab hide event triggered.");
                     stopScanner(); // Call async stop function
                 });
            } else { console.error("Error: scan-tab element not found."); }

            // Also attempt to stop scanner if user navigates away or closes tab/window
            // Note: 'beforeunload' might not always complete async operations like stopping scanner
            window.addEventListener('beforeunload', () => {
                // console.log("[Debug] beforeunload event triggered. Attempting to stop scanner.");
                // This is a best-effort attempt, might not fully complete
                if (html5QrCode && html5QrCode.isScanning) {
                    stopScanner(); // Fire and forget attempt
                }
            });

            // console.log("[Debug] Event listeners attached.");
        });

    </script>

</body>
</html>
